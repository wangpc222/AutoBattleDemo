
---

### 🗺️ 成员 A：核心算法与地图架构 (The Architect)
**核心职责**：你不再只是存数据，你是**寻路服务提供商**。你必须提供一个“导航仪”。

1.  **网格数据结构 (Grid Data Structure)**
    *   继续你已经在做的二维数组 `std::vector<std::vector<Cell>>`。
    *   每个 `Cell` 结构体需要包含：`bool bIsWalkable` (是否可走), `Building* Occupant` (上面的建筑指针)。
    *   **接口**：`void BlockCell(int x, int y)` —— 当成员 C 造塔时调用，把格子标记为不可走。

2.  **手写 A* (A-Star) 或 BFS 寻路算法 (核心难点)**
    *   **这是整个项目最能体现 C++ 水平的地方。**
    *   **输入**：起点坐标 `(StartX, StartY)`，终点坐标 `(EndX, EndY)`。
    *   **输出**：`std::vector<FVector>` —— 一连串的世界坐标点（路径点列表）。
    *   **实现细节**：
        *   使用 `std::priority_queue` (优先队列) 来管理待检查的节点。
        *   使用 `std::unordered_map` 来记录父节点（Parent Pointer），用于回溯路径。
        *   **如果觉得 A* 太难**，先写 **BFS (广度优先搜索)**，对于没有地形权重的网格，效果一样且更简单。

---

### ⚔️ 成员 B：单位行为与移动执行 (The Commander)
**核心职责**：你拿着成员 A 给的“路径点”，控制士兵**物理移动**过去，并处理战斗。

1.  **手写移动逻辑 (Custom Movement)**
    *   因为不用 NavMesh，你不能调 `SimpleMoveTo`。你得在 `Tick` 里自己写插值。
    *   **逻辑流程**：
        1.  士兵生成时，调用成员 A 的接口 `GetPath(MyPos, EnemyPos)`，拿到 `PathPoints` (一个坐标数组)。
        2.  **Step 1**: 取出数组第一个点，设为 `CurrentTargetPoint`。
        3.  **Step 2 (在 Tick 中)**：计算 `(Target - Self).Normalize()` 得到方向，然后 `AddActorWorldOffset(Direction * Speed * DeltaTime)`。
        4.  **Step 3**: 当 `Distance(Self, CurrentTargetPoint) < 10.0f` (到了)，取出数组下一个点。
        5.  **Step 4**: 数组空了，说明到了终点，开始攻击。

2.  **战斗状态机 (Combat FSM)**
    *   状态：`Idle` -> `Pathing` (正在走格子) -> `Scanning` (找新目标) -> `Attacking` (攻击)。
    *   **重点**：当攻击目标（比如大本营）被摧毁后，需要重新向成员 A 请求新的路径去下一个目标。

3.  **兵种差异化**
    *   创建 `Soldier` (近战) 和 `Archer` (远程)。
    *   远程兵不需要走到终点，只要走到 `PathPoints` 里距离终点 `AttackRange` 以内的某个点就可以停下来攻击了。

---

### 🏗️ 成员 C：世界构建与交互桥梁 (The Builder)
**核心职责**：你是上帝之手，负责把 A 的格子和 B 的士兵串起来。

1.  **坐标转换系统 (Coordinate System)**
    *   **世界转格子**：鼠标点击 `(X=1500, Y=200)` -> 算出是 `Grid[5][2]`。
    *   **格子转世界**：士兵要走到 `Grid[5][2]` -> 算出世界坐标是 `(X=1500, Y=200)`。
    *   你需要写好这套转换工具函数，供 A 和 B 使用。

2.  **动态生成与阻挡 (Spawning & Blocking)**
    *   **造塔逻辑**：
        1.  玩家点击建造。
        2.  **检查**：调用 A 的接口 `IsWalkable(x, y)`，如果是 false，显示红色，不让造。
        3.  **建造**：生成建筑 Actor。
        4.  **锁定**：调用 A 的接口 `BlockCell(x, y)`。**这一步至关重要**，否则 B 的士兵会直接穿墙穿过防御塔（因为 A 的寻路算法不知道这里多了个塔）。

3.  **资源与 UI**
    *   简单的金币系统。
    *   Start Game 按钮：点击后，生成所有士兵，士兵开始向成员 A 请求路径（游戏开始）。

---

### 🤝 三人协作数据流 (Workflow)

为了搞定这个“不含 NavMesh”的系统，你们的代码交互流程是这样的：

1.  **C (玩家操作)**：在位置 `(10, 10)` 放了一个防御塔。
    *   `GridSystem->SetWalkable(10, 10, false);`
2.  **C (玩家操作)**：点击“开始战斗”。
3.  **B (士兵出生)**：在 `(0, 0)` 生成士兵。
4.  **B (士兵思考)**：我要去打大本营 `(20, 20)`，怎么走？
    *   调用 `Path = GridSystem->FindPath(Start(0,0), End(20,20));`
5.  **A (核心算法)**：疯狂运算 BFS/A*... 算出一条避开 `(10, 10)` 的路线：`[(0,1), (0,2)... (9,10), (11,10)...]`。
6.  **B (士兵执行)**：收到路径，开始在 Tick 里一格一格移动。

---

### 💡 避坑提示 (针对手写移动)

1.  **平滑移动**：
    *   如果你直接让士兵瞬间瞬移到下一个格子，看起来像跳棋。
    *   **成员 B** 必须使用 `FMath::VInterpTo` 或简单的向量加法 `Location + Direction * Speed * DeltaTime` 来做平滑移动。
2.  **卡住处理**：
    *   如果寻路算不出来（比如防御塔把大本营围死了），成员 A 的函数要返回空数组。
    *   成员 B 收到空数组时，让士兵原地待机（Idle）或者攻击最近的墙。
3.  **Z轴问题**：
    *   既然是手写移动，**忽略 Z 轴**。所有的距离计算、路径计算都只看 X 和 Y。否则士兵可能会因为地面不平而卡在半空中。

**评价**：这个方案虽然难，但如果做出来了，**绝对符合“超级加分”项**。你们是在通过 C++ 编写核心 Gameplay 算法，而不是简单的调用引擎 API。加油！



为了避免 Git 冲突，**数据（Grid）与表现（Actor）分离**。

---

### 📅 团队协作总原则 (避免冲突的铁律)
1.  **代码 (C++)**：大家可以同时写，只要不改同一个 `.cpp` 文件。**核心是先定好头文件 (.h)**。
2.  **关卡 (.umap)**：**严禁**两人同时修改 `Map_Main`。**指定成员 C 为地图唯一负责人**。
3.  **蓝图 (.uasset)**：
    *   **成员 B** 独占 `Blueprints/Units/` 文件夹（改兵种）。
    *   **成员 C** 独占 `Blueprints/Buildings/` 和 `UI/` 文件夹（改建筑和界面）。
    *   **成员 A** 不需要动蓝图，只写纯 C++。

---

### 🗺️ 成员 A：算法架构师 (The Architect)
**职责**：构建看不见的“逻辑网格”，提供寻路 API。

#### 1. 需要设计的 C++ 类
*   **`FGridNode` (结构体/纯 C++ 类)**
    *   *不是 Actor，只是数据。*
    *   属性：`X`, `Y` (坐标), `bIsWalkable` (是否可走), `Cost` (寻路权重), `Parent` (用于 A* 回溯)。
*   **`AGridManager` (继承 AActor)**
    *   *这是一个单例性质的管理者，放场景里。*
    *   属性：`TArray<TArray<FGridNode>> GridData` (二维数组核心数据)。
    *   属性：`Vector2D CellSize` (比如 100x100 一个格子)。
    *   **API (给 B 和 C 用)**：
        *   `FVector GridToWorld(int x, int y)`
        *   `FIntPoint WorldToGrid(FVector Location)`
        *   `bool IsTileWalkable(int x, int y)`
        *   `void SetTileWalkable(int x, int y, bool bWalkable)`
    *   **核心算法 API**：
        *   `TArray<FVector> FindPath(FVector Start, FVector End)`
        *   *注：这是 A 的工作核心，实现 BFS 或 A*。*

#### 2. 涉及的 .uasset / .umap
*   **几乎没有**。你只需要把 `AGridManager` 拖入场景一次（由成员 C 代劳），或者自己在空场景测试。
*   **主要工作区**：VS2019。

#### 3. 工作流程
1.  先定义 `AGridManager.h`，把上面的 API 函数名写好（函数体留空或返回假数据），提交 Git。**这样 B 和 C 就能开始写代码调用你了，不用等你算完。**
2.  实现“世界坐标 <-> 格子坐标”转换逻辑。
3.  实现 `SetTileWalkable`。
4.  **最后攻坚**：实现 `FindPath` 里的 A* 算法。

---

### ⚔️ 成员 B：战斗指挥官 (The Commander)
**职责**：让兵种动起来，去打架。

#### 1. 需要设计的 C++ 类
*   **`ABaseCharacter` (继承 ACharacter 或 APawn)**
    *   *注：既然手写移动，用 APawn 其实更自由，但 Character 自带胶囊体比较方便。*
    *   属性：`TArray<FVector> CurrentPath` (存储 A 计算出的路径)。
    *   属性：`int CurrentPathIndex` (当前走到第几个点了)。
    *   函数：`MoveAlongPath(float DeltaTime)` (在 Tick 里调用，手动插值移动)。
    *   状态机：`Enum State { Idle, Moving, Attacking }`。
*   **`ASoldier` / `AArcher` (继承 ABaseCharacter)**
    *   重写 `Attack()`。

#### 2. 涉及的 .uasset / .umap
*   **Blueprints/Units/** 文件夹。
*   你需要创建 `BP_Soldier`，设置模型（球/胶囊），设置移动速度数值。
*   **严禁**修改主地图，你在自己的 `TestMap_B` 里测试移动。

#### 3. 工作流程
1.  等待 A 提交 `AGridManager.h`。
2.  在 `ABaseCharacter::BeginPlay` 里获取 `AGridManager` 的引用。
3.  **核心逻辑**：
    *   生成时，调用 `GridManager->FindPath(MyLoc, EnemyLoc)`。
    *   在 `Tick` 里：
        *   获取 `CurrentPath[Index]` 作为目标点。
        *   计算方向向量。
        *   `AddActorWorldOffset(Dir * Speed * DeltaTime)`。
        *   判断 `FVector::Dist(Me, Target) < 10` ? 如果是，Index++。
        *   Index 走完了？切换状态为 Attacking。

---

### 🏗️ 成员 C：世界构建者 (The Builder)
**职责**：处理输入，放置建筑，管理游戏流程。

#### 1. 需要设计的 C++ 类
*   **`ARTSPlayerController` (继承 APlayerController)**
    *   函数：`HandleClick()`。将鼠标点击转换为 Grid 坐标。
    *   逻辑：点击 -> 调用 `GridManager->IsTileWalkable` -> 如果 True -> 生成建筑 -> 调用 `GridManager->SetTileWalkable(false)`。
*   **`ABaseBuilding` (继承 AActor)**
    *   属性：`GridPosition` (X, Y)。
*   **`ARTSGameMode` (继承 AGameModeBase)**
    *   逻辑：管理金币，判断游戏胜利/失败。
    *   UI 绑定：提供 `UFUNCTION` 给蓝图 UI 调用，如 `SpawnUnit()`。

#### 2. 涉及的 .uasset / .umap
*   **Map_Main.umap**：你是地图的**唯一主人**。负责放光照、地板、把 A 的 GridManager 拖进去。
*   **Blueprints/Buildings/**：防御塔蓝图。
*   **UI/**：UMG 界面（开始按钮、造兵按钮）。

#### 3. 工作流程
1.  建立 `Map_Main`，放一个巨大的地板，调整摄像机。
2.  实现点击生成建筑逻辑：
    *   **关键**：生成建筑后，必须告诉 A 的 GridManager **“这里堵住了”**。
3.  实现 UI：点击“Spawn Unit”按钮，在指定位置生成 B 的 `BP_Soldier`。

---

### 🛡️ 冲突避免操作手册 (Checklist)

#### 1. 接口先行 (Interface First)
在开始写复杂逻辑前，三人先开个会，把 `GridManager.h` 里的函数名定死。
*   A 说：“我会提供 `FindPath(Start, End)`。”
*   B 说：“好，我到时候直接调。”
*   **A 先把这个空函数提交上去**，B 就可以写代码了，不用等 A 真的把 A* 算法写完。

#### 2. 蓝图互斥 (Asset Locking)
*   **B** 绝对不要去改 **Map_Main**，也不要去改 **防御塔蓝图**。
*   **C** 绝对不要去改 **士兵蓝图**。
*   如果必须改别人的东西（比如 C 发现士兵模型太大了），在群里说一声让 B 改。

#### 3. 调试分离
*   **A** 在代码里写 `DrawDebugLine` (画线) 来调试数据，不需要依赖美术模型。
*   **B** 在自己的 `TestMap_Unit` 里放几个固定的球当障碍物，测试士兵会不会绕着走。
*   **C** 在 `Map_Main` 里整合大家的功能。

#### 4. 每日合并
*   每天晚上必须 Commit 并 Push。
*   Push 前先 Pull。
*   Visual Studio 如果提示 `.cpp` 冲突，通常是纯文本冲突，很好解决（保留双方的代码即可）。

按照这个流程，实际上是在写**三个独立的模块**，最后通过 `GridManager` 这个接口拼装在一起，最大程度避免了“打架”。