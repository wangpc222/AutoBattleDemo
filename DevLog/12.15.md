# 分工更新

### 🗺️ 成员 A：底层架构与地图系统 (The Architect)
**核心职责**：你不需要关心“这个兵长什么样”，你只关心“数据结构”和“算法”。

#### 1. C++ 核心任务
*   **网格系统升级 (`GridManager`)**：
    *   **动态阻挡更新**：实现 `UpdateTileStatus(x, y, bBlocked)`。当墙被炸弹人炸毁时，必须动态把该格子设为“可走”，并通知成员 B 的单位重新寻路。
    *   **多地图支持**：设计一个数据结构（如 `UDataAsset` 或简单的结构体数组）来存储“关卡数据”。例如：第一关在 (5,5) 有个炮塔，第二关在 (10,10) 有个大本营。
*   **寻路算法优化 (`Pathfinding`)**：
    *   **A* 算法**：必须稳定。
    *   **流场寻路 (Flow Field) [进阶可选]**：如果兵很多，A* 会卡。如果想拿高分，可以研究一下针对大量单位的流场算法（所有兵去同一个目的地）。

#### 2. 蓝图/资产任务
*   **Map Data**：不用摆场景，而是配置 2 个不同的纯数据文件（C++ struct），定义两关的敌人建筑布局。

---

### ⚔️ 成员 B：战斗 AI 与单位行为 (The Commander)
**核心职责**：实现 4 种兵种的差异化逻辑，以及防御塔的攻击逻辑。

#### 1. C++ 核心任务
*   **单位分化 (`ABaseUnit` 的子类)**：
    *   **野蛮人 (Barbarian)**：默认逻辑，找最近的建筑打。
    *   **弓箭手 (Archer)**：**远程攻击**。不需要走到目标脸上，只要 `Distance(Self, Target) <= AttackRange` 就停下来开火。
    *   **巨人 (Giant)**：**优先级 AI**。重写 `FindClosestEnemy()`，优先搜索 `BaseDefenseBuilding`（防御塔），如果没有防御塔了才打普通建筑。
    *   **炸弹人 (WallBreaker)**：**自爆逻辑**。优先找 `Wall`（墙），走到旁边触发 `SuicideAttack()`，造成高额范围伤害并销毁自己。
*   **防御塔逻辑 (`BaseDefenseBuilding`)**：
    *   在 `Tick` 里检测范围内最近的敌人。
    *   生成投射物（箭矢/炮弹）攻击敌人。
*   **建筑升级属性**：在基类里实现“等级”系统，等级越高，血量/攻击力越高。

#### 2. 蓝图/资产任务
*   **制作 4 个兵种蓝图**：调整移动速度、血量、攻击距离。
*   **制作防御塔蓝图**：设置攻击范围、开火频率。

---

### 🏗️ 成员 C：经济系统与游戏循环 (The Builder/Manager)
**核心职责**：你负责“经营”部分（造房子、产资源）和“流程”部分（开始战斗、结算）。

#### 1. C++ 核心任务
*   **经济系统 (`EconomyManager` 或写在 `GameMode` 里)**：
    *   **三类资源**：实现金币、圣水、人口的存储和扣除。
    *   **资源产出**：编写 `ResourceBuilding` (矿场)。在 `Tick` 里每秒增加资源：`CurrentResource += ProductionRate * DeltaTime`。
    *   **存储限制**：资源不能超过 `MaxStorage`。
*   **建造系统升级 (`PlayerController`)**：
    *   **建筑排布**：之前的点击生成逻辑，需要加上“扣除资源”和“检查人口”的判断。
    *   **建筑升级**：实现点击已放置的建筑，弹出“升级”按钮，扣钱，提升属性（调用 B 写好的等级接口）。
*   **游戏流程控制 (`GameMode`)**：
    *   **胜负判定**：
        *   **胜**：敌人“大本营”被摧毁。
        *   **负**：我方兵死光了且没推掉大本营，或时间耗尽。
    *   **关卡切换**：胜利后，根据剩余兵种计算金币奖励，加载下一张地图（读取 A 的地图数据）。

#### 2. 蓝图/资产任务
*   **UI 系统**：
    *   **HUD**：显示金币、圣水、人口。
    *   **商店页**：点击造兵、造建筑。
    *   **结算页**：胜利/失败结算面板（显示星星）。
*   **场景搭建**：
    *   负责 `PlayerBase` 和 `Level_1`, `Level_2` 的美术搭建（放光照、地形装饰，别放逻辑建筑，逻辑建筑由代码生成）。

---

### 📝 必须实现的 C++ 类清单 (查漏补缺)

为了满足 PDF 要求，你们的代码库里至少应该有这些类：

#### 成员 A
1.  `AGridManager` (核心网格)
2.  `ULevelDataAsset` (用于存两张地图的配置，继承自 UDataAsset)

#### 成员 B
1.  `ABaseGameEntity` (所有东西的父类)
2.  `ABaseUnit` (兵基类)
    *   `ASoldier_Barbarian`
    *   `ASoldier_Archer`
    *   `ASoldier_Giant`
    *   `ASoldier_Bomber`
3.  `ABaseBuilding` (建筑基类)
    *   `ABuilding_Defense` (塔)
    *   `ABuilding_Resource` (矿)

#### 成员 C
1.  `ARTSGameMode` (规则与流程)
2.  `ARTSPlayerController` (交互与建造)
3.  `URTSGameInstance` (跨关卡资源保存)
4.  `ARTSHUD` (UI管理)

---

### ⚡️ 协作中的“高危”冲突点

1.  **B 和 C 的冲突**：
    *   **场景**：C 做 UI 点击升级建筑，B 写建筑的属性。
    *   **解决**：B 负责在 `ABaseBuilding` 里写好 `LevelUp()` 函数（加血加攻），C 只需要在 UI 点击事件里调用 `Building->LevelUp()`，**不要在 UI 里写升级的数值逻辑**。

2.  **A 和 B 的冲突**：
    *   **场景**：炸弹人把墙炸了，A 的网格没更新，别的兵还在绕路。
    *   **解决**：B 在墙销毁的 `Destroy()` 之前，必须调用 `GridManager->SetTileBlocked(x, y, false)`。

3.  **A 和 C 的冲突**：
    *   **场景**：地图怎么加载？
    *   **解决**：C 在 `GameMode::BeginPlay` 里，读取 A 定义的 `LevelData`，然后生成敌人的建筑。不要直接把敌人建筑拖在地图里存成 .umap，因为那样很难复用。**全部动态生成 (SpawnActor)** 是最稳妥的。

